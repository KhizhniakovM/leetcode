# 0070. Climbing Stairs

# You are climbing a staircase. It takes n steps to reach the top.
# Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

# Example 1:
#   Input: n = 2
#   Output: 2
#   Explanation: There are two ways to climb to the top.
#       1. 1 step + 1 step
#       2. 2 steps

# Example 2:
#   Input: n = 3
#   Output: 3
#   Explanation: There are three ways to climb to the top.
#       1. 1 step + 1 step + 1 step
#       2. 1 step + 2 steps
#       3. 2 steps + 1 step


# Constraints:
#   1 <= n <= 45

# ==================================================
# Нам дано количество ступеней лестницы
# Мы можем делать подниматься на 1 ступеньку или на 2 ступеньки
# Необходимо вернуть количество всех возможных способов подняться по лестнице
# Пример:
#   Дано 2 ступеньки
#   Мы можем подняться на них одним из двух способов
#       - +1 +1
#       - +2
#
# Максимальное количество ступенек 45, это значит, что алгоритм непростой
# и есть возможность решать его рекурсивно


# [1,1,1,1,1]
# |\_______
# |        \
# |         \
# [2,1,1,1], [1,2,1,1], [1,1,2,1], [1,1,1,2]
# |
# [2,2,1], [2,1,2]


# Можно попробовать найти минимальное и максимальное количество "разрядов" в этом списке
# Оно будет равно максимальному количеству двоек
# Если число n, то максимальная длина n, а минимальная n / 2, с округлением вверх

# Попробуем решить с маленькой и будем усложнять
# for n in range(2, 1, -1)

# максимальное число разрядов и минимальное число разрядов


# // Можно попробовать обьединять рядом стоящие единицы


# ! HINT -> To reach nth step, what could have been your previous steps? (Think about the step sizes)

# Если мы будем считать каэжый шаг, прибавляя по 2 единицы и считая 2 попытки
# То есть если заведомое число 2, то мы прибавляем


# _ _ _ _ _ _ _ _ _ _
#
#
# ==================================================


class BruteForceSolution:
    # Time O(2^n) -> tooooo slow
    # Memory O(n)
    def climbStairs(self, n: int) -> int:

        def _climb_rec(current: int) -> int:
            if current > n:
                return 0
            if current == n:
                return 1

            return _climb_rec(current + 1) + _climb_rec(current + 2)

        result = _climb_rec(0)

        return result


# ==================================================
# Correct Dynamic Programming Solution
# DP BottomUp Solution

# Попробуем решить проблему с конца
# Представим, что нам нужно достичь числа 5
# Попробуем определить сколько способов достаичь сила 5 из числа 5

# ! По дефолту говорим, что есть 1 такой способ?
# Записываем его в массив в конце
# [_,_,_,_,_,1]
# Теперь считаем сколько способов из числа 4 достичь числа 5
# Такой способ только 1
# Записываем его тоже
# [_,_,_,_,1,1]
# Теперь считаем из числа 3
# Таких способов 2: 3 + 2, 3 + 1 + 1
# [_,_,_,2,1,1]
# Теперь считаем из числа 2
# Из него мы можем перейти только в числа 4: 2+2 или 3: 2+1,
# а для этих чисел мы уже посчитали количество возможных вариантов, поэтому можем просто их сложить
# [_,_,3,2,1,1]
# Из 1
# [_,5,3,2,1,1]
# Из 0
# [8,5,3,2,1,1]
# Ответ - 8
# ==================================================


class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2

        one, two = 1, 2
        for _ in range(2, n):
            one, two = two, one + two
        return one
